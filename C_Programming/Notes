http://www.rmbconsulting.us/a-c-test-the-0x10-best-questions-for-would-be-embedded-programmers

1. String literal concatenation

Adjacent string literals are concatenated at compile time; this allows long strings to be split over multiple lines, and also allows string literals resulting from C preprocessor defines and macros to be appended to strings at compile time:

    printf(__FILE__ ": %d: Hello "
           "world\n", __LINE__);

will expand to

    printf("helloworld.c" ": %d: Hello "
           "world\n", 10);

which is syntactically equivalent to

    printf("helloworld.c: %d: Hello world\n", 10);

2. According to The C Programming Language book by Dennis Ritchie which is the 
   de-facto standard book for ANSI C, plain chars either signed or unsigned are 
   machine dependent, but printable characters are always positive.


   ASCII character set defines codepoints from 0x00 to 0x7F. It doesn't matter if they are represented with unsigned or signed byte values since this range is common for both.

Printable characters are between 0x20 and 0x7E, which are all part of the ASCII. The term printable character does not define every possible character in the world that is printable. Rather it is defined inside the realm of ASCII.


Byte values from 0x80 to 0xFF are not defined in ASCII and different systems assign different characters to values in this range resulting in many different types of codepages which are identical in their ASCII range but differ in this range. This is also the range where values for signed and unsigned bytes differ.
The implementation of printf looks for a single byte value when it encounters a %c key in its input. This byte value may be signed or unsigned with respect to your point of view as the caller of printf function but printf does not know this. It just passes these 8bits to the output stream it's connected to and that stream emits characters within 0x00 and 0xff.
The concept of sign has no meaning inside the output pipeline where characters are emitted. Thus, whether you send a 255 or a -1, the character mapped to 0xFF in the specific codepage is emitted.

3. Enumeration better than #define

An enumeration is like a fancy integer, and it's better than defining a whole load of constants or preprocessor macros as names for 
the constant values you want to store, because a compiler (or editor) can check that you're using the right names and values to go 
with the right type. On the other hand, being just an int, there's nothing stopping you putting in a value you didn't make a name for
, which is occasionally useful. They can't be checked in every case. What if you add two numbers together to get the value that's 
going to be put in the enum-typed variable? It could be any value, generated at runtime, so it can't be checked (without a lot of 
overhead, at least).Everything in C is unsafe; there's practically no feature which the compiler can totally prevent you from abusing. enums are safe because they are effective at preventing programmer error and confusion, not because they stop you doing something stupid.

You don't have explicitly give every state a number, the compiler does the numbering for you. Let's assume you have already 20 states and you want to add a new state in the middle, in case of defines, you have to do all renumbering on your own. In case of enumeration, you can just add the state and the compiler will renumber all states below this new state for you.

/****************************************************************************
 *
 *  Enumeration example: This program will fail to compile because the 
 *  preprocessor will change the FALSE to 1 on the enum statement....
 *
 ****************************************************************************/

#define FALSE 1

main()
{

  enum Boolian_t {FALSE=0, TRUE} Boolian;
    
  printf("False has a value of %d", FALSE);
  printf(" True has a value of %d", TRUE);
}

References

http://blog.feabhas.com/2011/06/enum-past-present-and-future/
http://codingrelic.geekhold.com/2008/10/ode-to-enum.html
http://www.lix.polytechnique.fr/~liberti/public/computing/prog/c/C/SYNTAX/enum.html
http://cinterviewquetions.blogspot.in/2011/11/what-is-benefit-of-using-enum-rather.html

Unfortunately, using the enum method of declaring constants takes up slightly more memory space than using the #define method of 
declaring constants, because a memory location must be set up to store the constant.

4. Truncation of / and the sign of the result of % are machine-dependent
 
References
http://praisecurseandrecurse.blogspot.in/2006/12/division-bell-tolls-for-me-part-four.html
http://stackoverflow.com/questions/17461486/what-are-the-rules-for-modular-arithmetic-in-c
References 
	http://yeda.cs.technion.ac.il/~yona/c/lecture3/all_in_one.html1

5. Implicit Conversations and Integral Conversations

A. Noncompliant Code Example (Comparison)

The programmer must be careful when performing operations on mixed types. This noncompliant code example shows an idiosyncracy of integer promotions.
int si = -1;unsigned int ui = 1;

printf(“%d\n”, si < ui);

Compliant Solution

The noncompliant code example can be modified to produce the intuitive result by forcing the comparison to be performed using signed int values.
int si = -1;unsigned ui = 1;

printf(“%d\n”, si < (int)ui);

This program prints 1 as expected. Note that (int)ui is correct in this case only because the value of ui is known to be representable as an int. If it were not known, the compliant solution would need to be written as
int si = /* some signed value */;unsigned ui = /* some unsigned value */;

printf(“%d\n”, (si < 0 || (unsigned)si < ui));
In this example, the comparison operator operates on a signed int and an unsigned int. By the conversion rules, si is converted to an unsigned int. Because −1 cannot be represented as an unsigned int value, the −1 is converted to UINT_MAX. 

Noncompliant Code Example

This noncompliant code example demonstrates how performing bitwise operations on integer types smaller than int may have unexpected results.
uint8_t port = 0x5a;uint8_t result_8 = ( ~port ) >> 4;

In this example, a bitwise complement of port is first computed and then shifted 4 bits to the right. If both of these operations are performed on an 8-bit unsigned integer, then result_8 will have the value 0x0a. However, port is first promoted to a signed int, with the following results (on a typical architecture where type int is 32 bits wide):
Expression 	Type 	Value 	Notes
port 	uint8_t 	0x5a 	
~port 	int 	0xffffffa5 	
~port >> 4 	int 	0x0ffffffa 	Whether or not value is negative is implementation-defined.
result_8 	uint8_t 	0xfa 	

Compliant Solution

In this compliant solution, the bitwise complement of port is converted back to 8 bits. Consequently, result_8 is assigned the expected value of 0x0aU.
uint8_t port = 0x5a;uint8_t result_8 = (uint8_t) (~port) >> 4;

B. Deep C: Integer Promotion

Nov 21st, 2012

Almost every programmer has learned about C, and a lot of them use it for their career. It is certainly one of the most popular programming languages on TIOBE (first place in November 2012). Yet, C can be really tricky and behave unexpectedly sometimes. One of those dodgy side of C is integer promotion. See the following example that illustrate the issue:

1
2
3
4
5
6
7
8
9

	

#include <stdio.h>

int main(void)
{
    unsigned char a = 0xff;
    char b = 0xff;
    int c = a==b; // true, or false?
    printf("C: %d\n",c);
}

You might think the output is 1, yet the answer is 0. Oops.
C99 SPEC

In the prior implementation of K&R and C89, arithmetic operands on short and char fell into two major camps and may produce different results from the above C snippet. In C99, integer promotion is clearly defined in following rule (6.3.1.1):

    If an int can represent all values of the original type, the value is converted to an int; otherwise, it is converted to an unsigned int. These are called the integer promotions. All other types are unchanged by the integer promotions.

Recall that the range of integer types:

    signed char: -127 to 127
    unsigned char: 0 to 255
    signed short: -32767 to 32767
    unsigned short: 0 to 65535
    signed int: -2147483647 to 2147483647

You can see that signed and unsigned char, short all can be represented in signed int, so they are all converted to signed int when doing arithmetic operations.

In the previous example, unsigned char a = 0xff is presenting 255. However, char b = 0xff is presenting -1. When both converted to int type, a remains 255, or 0x000000ff; b will be 0xffffffff which is -1 represented in int type. You can see how it works in this C snippet:

1
2
3
4
5
6
7
8
9

	

#include <stdio.h>

int main(void)
{
    unsigned char a = 0xff;
    char b = 0xff;
    printf("A: %08x, B: %08x\n", a, b);
    return 0;
}

The output would be:

A: 000000ff, B: ffffffff

This is why the result of expression a==b is 0.
Understand it at assembly level

When I first understood integer promotion rules, I got even more confused: why is this rule so awkward? To understand why it is designed like so, you must dig into compiled assembly code.

Let’s start with an easy example:

1
2
3
4
5
6
7

	

int main(void)
{
    unsigned char a = 0xff;
    char b = 0xff;
    int c = a + b;
    return 0;
}

The compiled assembly is:

1
2
3
4
5
6
7
8
9
10

	

movl    $0, -4(%rbp)        # The return value of main is 0
movb    $-1, -5(%rbp)       # unsigned char a = 0xff;
movb    $-1, -6(%rbp)       # char b = 0xff;
movzbl  -5(%rbp), %eax
movsbl  -6(%rbp), %ecx
addl    %eax, %ecx          # int c = a + b
movl    %ecx, -12(%rbp)     # store c onto the stack
movl    -4(%rbp), %eax
popq    %rbp
ret                         # return value 0 from eax

If you are not familiar with GAS syntax, you can check out X86 Assembly/GAS Syntax. GAS assembly instructions are generally suffixed with the letters “b”, “s”, “w”, “l”, “q” or “t” to determine what size operand is being manipulated.

    b = byte (8 bit)
    s = short (16 bit integer) or single (32-bit floating point)
    w = word (16 bit)
    l = long (32 bit integer or 64-bit floating point)
    q = quad (64 bit)
    t = ten bytes (80-bit floating point)

GAS convention is to push parameter from left-to-right. For instance, movl $0, -4(%rbp) means to move 0x00000000 to address -4(%rbp).

The instruction movzbl means moving a byte to long (32 bit int) with zero fill. movzbl -5(%rbp), %eax take 0xff to %eax and fill the rest with zero. %eax is now 0x000000ff.

The instruction movsbl means moving a byte to long with signed fill. movsbl -6(%rbp), %ecx take 0xff to %eax and fill the rest with signed value, which will cause %ecx to be 0xffffffff. Finally, addl %eax, %ecx do the add operation, and movl %ecx, -12(%rbp) store the result onto the stack.

Now, you understand that integer promotion is a rule how C types being mapped directly to machine instructions. All arithmetics operands are applied to smaller integers after they are transformed into int with signed or unsigned fill. You can think it this way: though short and char are stored in one or two byte, they are treated as int when you use it with arithmetic operations. The rule how they are transformed to int is called integer promotion.



    int foo (void) {
      signed char a = 1;
      unsigned char b = -1;
      return a > b;
    }

Here both values should be promoted to signed int and the comparison is then (1 > 255). 
References

C.  unsigned char c = 2;
    unsigned int  i = 2;

    printf("%d\n", c >> 9);
    printf("%d\n", i >> 33);
    printf("%d\n", c << 9);
    printf("%d\n", i << 33);

    Most Intel processors since 80286 use only the low five bits in the right hand operand, so the expressions above are in reality shifting the integers only one bit.

             Intel    PPC & ARM 
      c >> 9         0          0
      i >> 33        1          0
      c << 9         1024       1024
      i << 33        4          0

    
D.    signed char a = 127;
    printf("%d\n", (a + 1));
    printf("%d\n", ++a);

128
-128

Promoting a negative char value to integer, keeps the sign and value, and thus the output of the printf function will be -128. 

http://www.iesensor.com/blog/2012/10/21/unsigned-integer-can-be-evil-c-implicit-conversion/
http://www.idryman.org/blog/2012/11/21/integer-promotion/
http://stackoverflow.com/questions/5814072/sign-extend-a-nine-bit-number-in-c
http://graphics.stanford.edu/~seander/bithacks.html 				//	Sign Extension Programs
http://www.danielvik.com/2010/05/c-language-quirks.html // Good Read

A bit-field may have type int, unsigned int, or signed int.  // Search
